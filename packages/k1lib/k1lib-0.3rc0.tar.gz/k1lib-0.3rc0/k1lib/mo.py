# AUTOGENERATED FILE! PLEASE DON'T EDIT
"""This module is for all things related to atoms, molecules and their simulations"""
import k1lib, torch, math
from functools import partial
from typing import Dict, List
import matplotlib.pyplot as plt
__all__ = []
_depthAuto = k1lib.AutoIncrement()
_idxAuto = k1lib.AutoIncrement()
class Atom:
    def __init__(self, name, atomicN, massN, valenceE, radius=[], octetE=8):
        """Creates a new atom.

:param radius: covalent radiuses (in pm) for single, double and triple bonds
:param octetE: how many electrons in a full octet? Default 8, but can be 2 for H and He"""
        self.name = name; self.atomicN = atomicN; self.massN = massN
        self.ogValenceE = valenceE # original
        self.valenceE = valenceE; self.octetE = octetE; self.radius = radius
        self.bonds = [] # list of Atoms this Atom is bonded to
        self.gDepth = -1 # graph depth, for graph traversal stuff. Values will be updated from _depthAuto
        self.idx = f"A{_idxAuto()}" # unique value for Atoms everywhere
        # contracts:
        # - valenceE = eClouds * 2 + freeE + len(bonds) * 2
        # - valenceE <= octetE. "<" happens when octet not full
        # can only form a new bond if freeE >= 1. Can dec eClouds to inc freeE
        if name != "_e":
            self.eClouds = []; self.freeE = valenceE % 2
            for i in range(valenceE//2): self.eClouds.append(mo._e)
        else: self.eClouds = []; self.freeE = 0
    def nBonds(self, atom:"Atom"):
        """Get number of bonds between this and another atom."""
        return len([bond for bond in self.bonds if bond == atom])
    def __repr__(self):
        return f"""<Atom {self.name} ({self.atomicN}), {len(self.bonds)} bonds, {self.valenceE}/{self.octetE} valence electrons>"""
    def _show(self, g=None, gDepth=-1):
        self.gDepth = gDepth; g.node(self.idx, self.name)
        [g(self.idx, bond.idx) for bond in self.bonds if bond.name != "_e" and bond.gDepth < gDepth]
        [bond._show(g, gDepth) for bond in self.bonds if bond.name != "_e" and bond.gDepth < gDepth]
    def show(self):
        """Show the molecule graph this atom is a part of. Meant for debugging
simple substances only."""
        g = k1lib.graph(); self._show(g, _depthAuto()); return g
@k1lib.patch(Atom)
def _addFreeE(self, amt:int=1):
    """Adds free electron to atom."""
    if amt > 1: [self._addFreeE() for i in range(amt)]
    self.freeE += 1
    if self.freeE >= 2: self.eClouds.append(mo._e); self.freeE -= 2
@k1lib.patch(Atom)
def _subFreeE(self, amt:int=1) -> bool:
    """Tries to use ``amt`` free electrons. Returns successful or not."""
    if amt > 1: [self._subFreeE() for i in range(amt)]
    elif self.freeE > 0: self.freeE -= 1
    elif len(self.eClouds) > 0:
        self.freeE += 1; self.eClouds.pop()
    else: raise RuntimeError(f"Can't give away any more free electrons on atom {self.name}!")
@k1lib.patch(Atom)
def _makeRoom(self, nBonds:int):
    """Tries to remove bonds with Hydrogen to make room for ``nBonds`` more bonds."""
    nBondsToRemove = self.valenceE + nBonds - self.octetE
    if nBondsToRemove > 0:
        Hs = [bond for bond in self.bonds if bond.name == "H"]
        if len(Hs) >= nBondsToRemove:
            for i in range(nBondsToRemove): self.removeBond(Hs[i])
        else: raise RuntimeError("Can't remove Hydrogen bonds to make room for new bond!")
    availableE = len(self.eClouds) * 2 + self.freeE
    if availableE < nBonds: raise RuntimeError(f"Can't make room for {nBonds} new bonds on {self.name}. Only {availableE} electrons left for bonds!")
@k1lib.patch(Atom)
def __call__(self, atom:Atom, nBonds:int=1, main=False) -> Atom:
    """Forms a bond with another atom. If valence electrons are full, will
attempt to disconnect Hydrogens from self to make room.

:param bond: number of bonds. 2 for double, 3 for triple
:param main: whether to put this bond in front of existing bond, to
    signify the "main" chain, so that it works well with :meth:`next`
:return: self"""
    self._makeRoom(nBonds); atom._makeRoom(nBonds)
    if main: self.bonds = [atom] * nBonds + self.bonds
    else: self.bonds += [atom] * nBonds
    atom.bonds += [self] * nBonds
    self.valenceE += nBonds; self._subFreeE(nBonds)
    atom.valenceE += nBonds; atom._subFreeE(nBonds)
    return self
@k1lib.patch(Atom)
def bond(self, atom:Atom, nBonds:int=1, main=False) -> Atom:
    """Like :meth:`__call__`, but returns the atom passed in instead"""
    self(atom, nBonds, main); return atom
@k1lib.patch(Atom)
def main(self, atom:Atom, nBonds:int=1) -> Atom:
    """Like :meth:`bond`, but with ``main`` param defaulted to True."""
    return self.bond(atom, nBonds, True)
@k1lib.patch(Atom)
def removeBond(self, atom:"Atom"):
    """Removes all bonds between this and another atom"""
    nBonds = self.nBonds(atom)
    self.bonds = [bond for bond in self.bonds if bond != atom]
    self.valenceE -= nBonds; self._addFreeE(nBonds)
    atom.bonds = [bond for bond in atom.bonds if bond != self]
    atom.valenceE -= nBonds; atom._addFreeE(nBonds)
@k1lib.patch(Atom, "next")
def _next(self, offset=0, times:int=1) -> "Atom":
    """Returns the next atom bonded to this. Tries to avoid going into Hydrogens

:param offset: if there are multiple non-Hydrogen atoms, which ones should I pick?
:param times: how many times do you want to chain ``.next()``?"""
    nonHs = [bond for bond in self.bonds if bond.name != "H" and bond.name != "_e"]
    Hs = [bond for bond in self.bonds if bond.name == "H"]
    atoms = nonHs + Hs
    if len(atoms) == 0: return None
    _next = atoms[offset]
    if times == 1: return _next
    return _next.next(0, times-1)
_a = {} # dict of atoms, which will be used to patch the entire module
class _Mo: pass
mo = _Mo() # convenience object so that I can use the same style as the module
def _atom(name, *args, **kwargs):
    _a[name] = f = lambda: Atom(name, *args, **kwargs)
    setattr(_Mo, name, property(partial((lambda self, f: f()), f=f)))
# covalent radius taken from (Pyykko & Atsumi) https://chem.libretexts.org/@api/deki/pages/2182/pdf/A3%253A%2bCovalent%2bRadii.pdf?stylesheet=default
_atom("_e", 0,   0.1,    0, [15]) # electron cloud, for internal use
_atom("H",  1,   1.008,  1, [32], octetE=2)
_atom("Li", 3,   6.94,   1, [133, 124])
_atom("Be", 4,   9.0122, 2, [102, 90, 85])
_atom("B",  5,  10.81,   3, [85,  78, 73])
_atom("C",  6,  12.011,  4, [75,  67, 60])
_atom("N",  7,  14.007,  5, [71,  60, 54])
_atom("O",  8,  15.999,  6, [63,  57, 53])
_atom("F",  9,  18.998,  7, [64,  59, 53])
_atom("Na", 11, 22.990, 1, [155, 160])
_atom("Mg", 12, 24.305, 2, [139, 132, 127])
_atom("Al", 13, 26.982, 3, [126, 113, 111])
_atom("Si", 14, 28.085, 4, [116, 107, 102])
_atom("P",  15, 30.974, 5, [111, 102, 94])
_atom("S",  16, 32.06,  6, [103, 94,  95])
_atom("Cl", 17, 35.45,  7, [99,  95,  93])
_atom("K",  19, 39.098, 1, [196, 193])
_atom("Ca", 20, 40.078, 2, [171, 147, 133])
_atom("Ga", 31, 69.723, 3, [124, 117, 121])
_atom("Ge", 32, 72.630, 4, [121, 111, 114])
_atom("As", 33, 74.922, 5, [121, 114, 106])
_atom("Se", 34, 78.971, 6, [116, 107, 107])
_atom("Br", 35, 79.904, 7, [114, 109, 110])
def _mole(name, f):
    _a[name] = f
    setattr(_Mo, name, property(partial((lambda self, f: f()), f=f)))
_mole("H2O", lambda: mo.O(mo.H)(mo.H))
_mole("CH4", lambda: mo.C(mo.H)(mo.H)(mo.H)(mo.H))
_mole("COOH", lambda: mo.C(mo.O, 2)(mo.O(mo.H))(mo.H))
_mole("NH3", lambda: mo.N(mo.H)(mo.H)(mo.H))
_mole("CH3OH", lambda: mo.CH4(mo.H2O))
def glucose():
    o = mo.O
    o.bond(mo.CH4).bond(mo.CH3OH).bond(mo.CH3OH).bond(mo.CH3OH).bond(mo.CH3OH).bond(o)
    o.next().bond(mo.CH3OH); return o
_mole("glucose", glucose)
def cyclohexane():
    c = mo.CH4
    return c.bond(mo.CH4).bond(mo.CH4).bond(mo.CH4).bond(mo.CH4).bond(mo.CH4).bond(c)
_mole("cyclohexane", cyclohexane)
def benzene():
    c = mo.CH4
    return c.bond(mo.CH4, 2).bond(mo.CH4).bond(mo.CH4, 2).bond(mo.CH4).bond(mo.CH4, 2).bond(c)
_mole("benzene", benzene)
def adenine():
    n = mo.NH3
    c1 = n.bond(mo.CH4).bond(mo.NH3, 2).bond(mo.CH4)
    c2 = c1.bond(mo.CH4, 2); c2.bond(n)
    c1.bond(mo.CH4)(mo.NH3).bond(mo.NH3, 2).bond(mo.CH4).bond(mo.NH3, 2).bond(c2);
    return n
_mole("adenine", adenine)
def ribose():
    o = mo.H2O
    return o.bond(mo.CH4(mo.CH3OH)).main(mo.CH3OH).main(mo.CH3OH).main(mo.CH3OH).main(o)
_mole("ribose", ribose)
def adenosine(): ri = mo.ribose; ri.next(1)(mo.adenine); return ri
_mole("adenosine", adenosine)
def distV(x:torch.Tensor) -> torch.Tensor:
    """Distance vectors of points.

:param x: location Tensor of shape (n, 3)
:returns: vector Tensor of shape (n, n, 3)"""
    n = x.shape[0]
    return x.view(1, n, 3) - x.view(n, 1, 3)
@k1lib.patch(Atom)
def _s_bondLength(self, idx_i:Dict[str, int], bondLengths:torch.Tensor):
    """Calculates bond length for all bonds in this atom and stores in
``bondLengths``."""
    bonds = list(set(self.bonds)) + self.eClouds
    for atom in bonds:
        nBonds = self.nBonds(atom)
        bL = self.radius[nBonds-1] + atom.radius[nBonds-1]
        bondLengths[idx_i[self.idx], idx_i[atom.idx]] = bL
        bondLengths[idx_i[atom.idx], idx_i[self.idx]] = bL
class System:
    def __init__(self, mapping:Dict[str, Atom]):
        """Creates a new system that contains a molecule so that it can be simulated.

:param mapping: maps from atom index to :class:`Atom` object
:param x: location Tensor of shape (n, 3)"""
        self.mapping = mapping; self.atoms = list(mapping.values())
        self.i_idx = list(mapping.keys()); self.n = len(self.i_idx)
        self.idx_i = {idx:i for i, idx in enumerate(self.i_idx)}
        self.bondLengths = torch.zeros(self.n, self.n)
        for atom in self.atoms: atom._s_bondLength(self.idx_i, self.bondLengths)
        self.bondMask = (self.bondLengths > 0) + 0
        self._x = 50*torch.randn(self.n, 3)
        self._v = torch.zeros(self.n, 3)
        self._a = torch.zeros(self.n, 3)
        self.iMask = 1-torch.eye(self.n) # identity mask
    def simulate(self, t:int=10, dt:float=1.0) -> List[torch.Tensor]:
        """Simulate ``t`` steps, return position tensors for all atoms for all times"""
        every = (t // 100) or 1; xs = []
        r1 = k1lib.Range(t); r2 = k1lib.Range(1, 2)
        for i in range(t):
            self._calcForces(decay=r1.toRange(r2, i)); self._update(dt)
            if i % every == 0:
                xs.append(self._x.clone())
        return xs
    def __getitem__(self, idx) -> Atom:
        if isinstance(idx, str): return self.mapping[idx]
        return self.mapping[self.i_idx[idx]]
    def x(self, a:Atom): return self._x[self.idx_i[a.idx]]
    def v(self, a:Atom): return self._v[self.idx_i[a.idx]]
@k1lib.patch(System)
def _calcForces(self, decay=2):
    """
:param decay: make this big to ignore distant atoms"""
    n = self.n; dV = distV(self._x) # (n, n, 3)
    l = torch.sqrt((dV**2).sum(dim=2)) + 0.001
    dV = dV / l.view(n, n, 1) # normalized direction
    aBond = 10 * dV * torch.tanh((l-self.bondLengths)*self.bondMask/100).view(n, n, 1)
    vBond = aBond.sum(dim=1)
    aCou = dV * ((100/l)**decay).view(n, n, 1)
    vCou = .3 * aCou.clearNan().sum(dim=1)
    #vCou *= .2/math.sqrt((vCou**2).sum(dim=1).max())
    self._a = 10 * (vBond - vCou)
    return aBond, aCou, l, dV, vBond, vCou
@k1lib.patch(System)
def _update(self, dt:float=1.0):
    self._v += dt * self._a
    self._v = torch.clamp(self._v * 0.8, -10, 10) # friction
    self._x += dt * self._v
    #self._x *= 0.99 # universe wants to quish things down
    self._a.zero_()
@k1lib.patch(Atom)
def _system(self, mapping:Dict[str, Atom], gDepth:int):
    if self.gDepth >= gDepth: return
    self.gDepth = gDepth
    mapping[self.idx] = self
    for atom in self.bonds: atom._system(mapping, gDepth)
    for eCloud in self.eClouds: eCloud._system(mapping, gDepth)
@k1lib.patch(Atom)
def system(self) -> System:
    mapping = dict(); self._system(mapping, _depthAuto()); return System(mapping)
@k1lib.patch(Atom)
def _plot(self, ax, x:torch.Tensor, idx_i:Dict[str, int]):
    s = x[idx_i[self.idx]]
    #bonds = set([atom for atom in self.bonds if atom.name != "_e"])
    bonds = set([atom for atom in self.bonds])
    for atom in bonds:
        a = x[idx_i[atom.idx]]
        ax.plot([s[0], a[0]], [s[1], a[1]], [s[2], a[2]], "k")
@k1lib.patch(System)
def plot(self, x:torch.Tensor=None, ax=None):
    """Plots system.

:param x: location Tensor of shape (n, 3). If none provided, will use current locations
:param ax: matplotlib Axes, if you want to plot this on an existing plot"""
    if x is None: x = self._x
    if ax is None: ax = plt.figure(dpi=150).add_subplot(projection="3d")
    ax.clear(); com = x.mean(dim=0) # center of mass
    box = math.sqrt(((x - com.view(1, -1))**2).sum(dim=1).max())
    ax.set_xlim(com[0]-box, com[0]+box)
    ax.set_ylim(com[1]-box, com[1]+box)
    ax.set_zlim(com[2]-box, com[2]+box)
    for atom in self.atoms:
        if atom.name == "_e": continue
        atom._plot(ax, x, self.idx_i)
        s = x[self.idx_i[atom.idx]]
        ax.text(s[0], s[1], s[2], f"{atom.name} {atom.idx}", ha="center", va="center")
    return ax
@k1lib.patch(System)
def animate(self, xs:List[torch.Tensor], rotateSpeed=0.5):
    fig = plt.figure()
    ax = fig.add_subplot(projection="3d")
    plt.close(fig)
    def update(frame):
        self.plot(xs[frame], ax)
        ax.view_init(azim=frame*rotateSpeed)
    a = k1lib.FAnim(fig, update, len(xs)); plt.close(fig); return a.system()