import json
import os
import contextlib

from mock import patch

FAKE_ENV_VARS = {
    'ID': 'formation-1',
    'ACCOUNT': 'the-account',
    'SERVICENAME': 'c-formation-1',
    'HOSTNAME': 'localhost',
    'TYPE': 'db2'
}


class FakeKubernetesMap:
    """
    A fake KubernetesMap.

    Note: The fakery is not exhaustive, just enough for targeted testing.
    """

    def __init__(self, data):
        self.data = data

    def get(self, key, default):
        return self.data.get(key, default)

    def keys(self):
        return self.data.keys()

    def __getitem__(self, key):
        return self.data[key]

    def __setitem__(self, key, value):
        self.data[key] = value

    def __iter__(self):
        return iter(self.data)

    def __eq__(self, other):
        return self.data == other.data


class FakeKubernetesModel:
    """
    A barely adequate fake for API server responses.

    The Kubernetes client deserializes API server responses into model objects
    generated by Swagger. The `V1Secret` and `V1ConfigMap` models are similar in
    that they both have a `data` attribute, which is all we care about.
    """
    def __init__(self, data):
        self.data = data

    @classmethod
    def from_file(cls, mock_file):
        return cls(json.loads(mock_file.read())['data'])


FAKE_RESPONSES_DIR = 'mock_kubernetes_responses'
API_VERSION_ONE = 'v1'


def load_fixture(version, filename):
    current_dir = os.path.dirname(os.path.abspath(__file__))
    path_to_api_responses = os.path.join(current_dir, FAKE_RESPONSES_DIR, version)

    with open(os.path.join(path_to_api_responses, filename)) as mock_file:
        return FakeKubernetesModel.from_file(mock_file)


def mock_v1_secrets(name, namespace, *args, **kwargs):
    """Mock API server secrets responses."""
    del namespace, args, kwargs
    if name.endswith('-cert'):
        return load_fixture(API_VERSION_ONE, 'cert-secret.json')
    elif name.endswith('-bucket'):
        return load_fixture(API_VERSION_ONE, 'bucket-secret.json')
    elif name == 'c-formation-1':
        return load_fixture(API_VERSION_ONE, 'formation-secret.json')
    else:
        raise NotImplementedError("This should not be the case")


def mock_v1_configmaps(name, namespace, *args, **kwargs):
    """Mock API server configmaps responses."""
    del namespace, args, kwargs
    if name == 'c-formation-1':
        return load_fixture(API_VERSION_ONE, 'formation-configmap.json')
    else:
        raise NotImplementedError("This should not be the case")


def env_var_faker(env_vars):
    """Return fake environment variables."""
    def fake_environment_variables(var, *args, **kwargs):
        del args, kwargs
        return env_vars.get(var, None)
    return fake_environment_variables


# hostname is only used by Configuration... move out?
@contextlib.contextmanager
def mock_kubernetes_v1_responses(env_vars=None, hostname='host-123'):
    """Mock everything needed to fake out the Kubernetes client."""
    env_vars = env_vars or FAKE_ENV_VARS
    with patch('os.getenv', side_effect=env_var_faker(env_vars)), \
            patch('kubernetes.config.load_incluster_config', side_effect=lambda: True), \
            patch('socket.gethostbyname', return_value=hostname), \
            patch('kubernetes.client.ApiClient', side_effect=lambda config: {}), \
            patch('kubernetes.client.apis.CoreV1Api.read_namespaced_secret',
                  side_effect=mock_v1_secrets), \
            patch('kubernetes.client.apis.CoreV1Api.read_namespaced_config_map',
                  side_effect=mock_v1_configmaps):

        yield
