import logging
logger = logging.getLogger('')
logger.setLevel(logging.INFO)

def get_optimization_direction(catboost_eval_metric):
    logging.info("Fetching optimization_direction for :" +catboost_eval_metric)
    direction_mapping = {
        'RMSE':  "minimize",
        'Logloss':  "minimize",
        'MAE':  "minimize",
        'CrossEntropy' :  "minimize",
        'Quantile':  "minimize",
        'LogLinQuantile':  "minimize",
        'Lq':  "minimize",
        'MultiRMSE':  "minimize",
        'MultiClass':  "minimize",
        'MultiClassOneVsAll'
        'MAPE':  "minimize",
        'Poisson':  "minimize",
        'PairLogit':  "minimize",
        'PairLogitPairwise':  "minimize",
        'QueryRMSE':  "minimize",
        'QuerySoftMax':  "minimize",
        'Tweedie':  "minimize",
        'SMAPE':  "maximize",
        'Recall':  "maximize",
        'Precision':  "maximize",
        'F1':  "maximize",
        'TotalF1':  "maximize",
        'Accuracy':  "maximize",
        'BalancedAccuracy':  "maximize",
        'BalancedErrorRate':  "maximize",
        'Kappa':  "maximize",
        'WKappa':  "maximize",
        'LogLikelihoodOfPrediction':  "maximize",
        'AUC':  "maximize",
        'R2':  "maximize",
        'FairLoss':  "maximize",
        'NumErrors':  "maximize",
        'MCC':  "maximize",
        'BrierScore':  "maximize",
        'HingeLoss':  "maximize",
        'HammingLoss':  "maximize",
        'ZeroOneLoss':  "maximize",
        'MSLE':  "maximize",
        'MedianAbsoluteError':  "maximize",
        'Huber':  "minimize",
        'Expectile':  "minimize",
        'PairAccuracy':  "maximize",
        'AverageGain':  "maximize",
        'PFound':  "maximize",
        'NDCG':  "maximize",
        'DCG':  "maximize",
        'FilteredDCG':  "maximize",
        'NormalizedGini':  "maximize",
        'PrecisionAt':  "maximize",
        'RecallAt':  "maximize",
        'MAP':  "maximize",
        'CtrFactor':  "maximize",
    }
    return direction_mapping.get(catboost_eval_metric, "Invalid eval metric")



def fetch_catboost_eval_metric( metric):
    logging.info("Fetching eval metric for :" + metric)

    metric_mapping = {
        'rmse' : 'RMSE',
        'logloss': 'Logloss',
        'mae': 'MAE',
        'crossentropy': 'CrossEntropy' ,
        'quantile': 'Quantile',
        'loglinquantile': 'LogLinQuantile',
        'lq': 'Lq',
        'multirmse': 'MultiRMSE',
        'multiclass': 'MultiClass',
        'multiclassonevsall': 'MultiClassOneVsAll',
        'mape': 'MAPE',
         'poisson': 'Poisson',
        'pairlogit': 'PairLogit',
        'pairlogitpairwise': 'PairLogitPairwise',
        'queryrmse': 'QueryRMSE',
        'querysoftmax': 'QuerySoftMax',
        'tweedie': 'Tweedie',
        'smape': 'SMAPE',
        'recall': 'Recall',
        'precision': 'Precision',
        'f1': 'F1',
        'totalf1': 'TotalF1',
        'accuracy': 'Accuracy',
        'balancedaccuracy': 'BalancedAccuracy',
        'balancederrorrate': 'BalancedErrorRate',
        'kappa': 'Kappa',
        'wkappa': 'WKappa',
        'loglikelihoodofprediction': 'LogLikelihoodOfPrediction',
        'auc': 'AUC',
        'r2': 'R2',
        'fairloss': 'FairLoss',
        'numerrors': 'NumErrors',
        'mcc': 'MCC',
        'brierscore': 'BrierScore',
        'hingeloss': 'HingeLoss',
        'hammingloss': 'HammingLoss',
        'zerooneloss': 'ZeroOneLoss',
        'msle': 'MSLE',
        'medianabsoluteerror': 'MedianAbsoluteError',
        'huber': 'Huber',
        'expectile': 'Expectile',
        'multirmse': 'MultiRMSE',
        'pairaccuracy': 'PairAccuracy',
        'averagegain': 'AverageGain',
        'pfound': 'PFound',
        'ndcg': 'NDCG',
        'dcg': 'DCG',
        'filtereddcg': 'FilteredDCG',
        'normalizedgini': 'NormalizedGini',
        'precisionat': 'PrecisionAt',
        'recallat': 'RecallAt',
        'map': 'MAP',
        'ctrfactor':'CtrFactor',
    }
    return metric_mapping.get(metric.lower().strip(), "Invalid Metric")


