# Copyright 2017 Laszlo Attila Toth
# Distributed under the terms of the GNU Lesser General Public License v3

"""
Current module is a sample how can the module framework extended.
The code is a generalized form of an actual usage.

As naming is hard, the _BaseModule and BasicModule might be strange,
but I did not want to use any specific name.

DETAILS:

Expectation: each message generated by the modules should be stored
in the config tree. As a result for easier usage, a common base module
is good choice. This is _BaseModule.

Depending on the environment, different startup phase may be necessary.
This is emulated by the two actual modules, GenericInitModule and
LinuxInitModule.
These module may read some files, parse them and change config tree.
For instance XML or other files can be loaded - not added here.

Every other module may run in any order, in this case another base class
can be useful, which provides the necessary require() method. This is
BasicModule.

The other modules can use values set by the init modules, such as
the Sample2Module.

The caller of modules may use the ModuleRunner, and prior that
it may set any value in config() to help even the "init" modules.
"""

import os.path
import sys

from dewi.config.config import Config
from dewi.module_framework.messages import Messages
from dewi.module_framework.module import Module
from dewi.module_framework.module_runner import ModuleRunner


class _BaseModule(Module):
    def __init__(self, config: Config, messages: Messages):
        super().__init__(config, messages, add_messages_to_config=True)


# -----------------------------------------------
# Initialize depending on the filter_tag

class GenericInitModule(_BaseModule):
    def provide(self) -> str:
        return 'init'

    def run(self):
        # Initialize what is necessary (in self.config)
        self.set('os_type', 'generic')


class LinuxInitModule(_BaseModule):
    def provide(self) -> str:
        return 'init'

    def get_filter_tags(self) -> list:
        return ['linux']

    def run(self):
        # Initialize what is necessary (in self.config)
        self.set('os_type', 'linux')


# -----------------------------------------------
# Base module of everything else, order of modules
# is not important, except that "init" must be the first one

class BasicModule(_BaseModule):
    def require(self) -> list:
        return ['init']


# -----------------------------------------------
# Actual modules


class SampleModule(BasicModule):
    def provide(self) -> str:
        return 'sample'

    def run(self):
        # Do something useful
        pass


class Sample2Module(BasicModule):
    def provide(self) -> str:
        return 'sample'

    def run(self):
        # Do something useful
        # Printing a value isn't really this, but a good example
        print(self.get('os_type'))


# -----------------------------------------------
# A caller function

def sample_run():
    config = Config()
    messages = Messages()

    # initializing config for modules might be useful
    config.set('_module_path', os.path.abspath(os.path.dirname(__file__)))

    runner = ModuleRunner()
    runner.add(GenericInitModule(config, messages))
    runner.add(LinuxInitModule(config, messages))
    runner.add(SampleModule(config, messages))
    runner.add(Sample2Module(config, messages))
    runner.add(Sample2Module(config, messages))

    filter_tag = 'linux' if sys.platform in ('linux', 'linux2') else None
    runner.run(filter_tag)
